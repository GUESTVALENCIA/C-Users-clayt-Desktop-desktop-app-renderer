// ============================================
// MODIFICACIONES PARA main.js - INTEGRACI√ìN NEON
// ============================================
// 
// INSTRUCCIONES:
// 1. Agregar la funci√≥n startNeonMCPServer() despu√©s de las importaciones (alrededor de l√≠nea 100)
// 2. Llamar startNeonMCPServer() en app.whenReady() (despu√©s de l√≠nea 433)
// 3. Modificar injectMCPBridge() para agregar soporte NEON (alrededor de l√≠nea 1105)
// 4. Modificar injectSystemPromptAndMemory() para usar NEON (alrededor de l√≠nea 1246)
//
// ============================================

// ============ PASO 1: AGREGAR DESPU√âS DE LAS IMPORTACIONES (alrededor de l√≠nea 100) ============

// Iniciar servidor MCP NEON en segundo plano
let neonMCPServer = null;

function startNeonMCPServer() {
  try {
    const { spawn } = require('child_process');
    const path = require('path');
    const neonServerPath = path.join(__dirname, 'mcp-server-neon.py');
    
    if (!fs.existsSync(neonServerPath)) {
      console.warn('[Main] ‚ö†Ô∏è  mcp-server-neon.py no encontrado. Memoria NEON no disponible.');
      return;
    }
    
    // Verificar si DATABASE_URL est√° configurado
    if (!process.env.DATABASE_URL) {
      console.warn('[Main] ‚ö†Ô∏è DATABASE_URL no configurada en variables de entorno');
      return;
    }
    const DATABASE_URL = process.env.DATABASE_URL;
    
    console.log('[Main] üöÄ Iniciando MCP Server NEON...');
    neonMCPServer = spawn('python', [neonServerPath], {
      cwd: __dirname,
      stdio: 'pipe',
      env: { ...process.env, DATABASE_URL }
    });
    
    neonMCPServer.stdout.on('data', (data) => {
      const msg = data.toString().trim();
      if (msg) console.log(`[MCP-NEON] ${msg}`);
    });
    
    neonMCPServer.stderr.on('data', (data) => {
      const msg = data.toString().trim();
      // Solo mostrar errores reales, no advertencias
      if (msg && !msg.includes('‚ö†Ô∏è') && !msg.includes('Advertencia')) {
        console.error(`[MCP-NEON] ${msg}`);
      }
    });
    
    neonMCPServer.on('close', (code) => {
      if (code !== 0 && code !== null) {
        console.warn(`[Main] ‚ö†Ô∏è  MCP Server NEON termin√≥ con c√≥digo ${code}`);
      }
    });
    
    console.log('[Main] ‚úÖ MCP Server NEON iniciado en puerto 8765');
  } catch (e) {
    console.warn('[Main] ‚ö†Ô∏è  No se pudo iniciar MCP Server NEON:', e.message);
  }
}

// ============ PASO 2: AGREGAR EN app.whenReady() (despu√©s de l√≠nea 433, antes de createWindow()) ============

// En app.whenReady().then(() => { ... }), agregar esta l√≠nea:
//   startNeonMCPServer(); // ‚Üê Agregar aqu√≠, despu√©s de iniciar QWEN Omni gateway

// ============ PASO 3: MODIFICAR injectMCPBridge() (alrededor de l√≠nea 1105) ============

// REEMPLAZAR la funci√≥n injectMCPBridge() completa con esta versi√≥n:

function injectMCPBridge(browserView) {
  if (!browserView || !browserView.webContents) return;
  
  const bridgeCode = `
    (function() {
      if (window.mcpBridgeInjected) return;
      window.mcpBridgeInjected = true;
      
      // API para comunicarse con el servidor MCP "sandra-full-access" (puerto 3001) - ACCESO COMPLETO AL PC
      window.mcpBridge = {
        // Llamar a endpoint espec√≠fico del servidor MCP
        call: async function(endpoint, params = {}) {
          try {
            const response = await fetch(\`http://localhost:3001\${endpoint}\`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(params)
            });
            const data = await response.json();
            return data;
          } catch (error) {
            console.error('[MCP Bridge] Error:', error);
            return { success: false, error: error.message };
          }
        },
        
        // ============ NUEVO: API para NEON (puerto 8765) - MEMORIA PERSISTENTE ============
        // Llamar a servidor MCP NEON para memoria persistente
        callNeon: async function(server, tool, arguments = {}) {
          try {
            const response = await fetch('http://localhost:8765/mcp', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                mcp: true,
                calls: [{
                  server: server,
                  tool: tool,
                  arguments: arguments
                }]
              })
            });
            const result = await response.json();
            return result.results?.[0]?.result || result;
          } catch (error) {
            console.error('[MCP Bridge NEON] Error:', error);
            return { error: error.message };
          }
        },
        
        // Obtener memoria desde NEON
        getMemory: async function(sessionId = 'clay_main', key = 'core_identity') {
          return await this.callNeon('reina', 'get_memory', { session_id: sessionId, key: key });
        },
        
        // Guardar memoria en NEON
        setMemory: async function(sessionId = 'clay_main', key = 'core_identity', value = {}) {
          return await this.callNeon('reina', 'set_memory', { session_id: sessionId, key: key, value: value });
        },
        
        // Listar recursos (archivos/carpetas) - ACCESO COMPLETO AL PC
        listResources: async function(uri = null) {
          try {
            const response = await fetch('http://localhost:3001/mcp/resources/list', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ uri })
            });
            const data = await response.json();
            return data;
          } catch (error) {
            return { success: false, error: error.message };
          }
        },
        
        // Leer archivo - ACCESO COMPLETO AL PC
        readFile: async function(uri) {
          try {
            const response = await fetch('http://localhost:3001/mcp/resources/read', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ uri })
            });
            const data = await response.json();
            return data;
          } catch (error) {
            return { success: false, error: error.message };
          }
        },
        
        // Ejecutar comando - ACCESO COMPLETO AL PC
        executeCommand: async function(command) {
          try {
            const response = await fetch('http://localhost:3001/mcp/command/execute', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ command })
            });
            const data = await response.json();
            return data;
          } catch (error) {
            return { success: false, error: error.message };
          }
        },
        
        // Verificar disponibilidad
        isAvailable: async function() {
          try {
            const response = await fetch('http://localhost:3001/health');
            const data = await response.json();
            return { success: true, available: data.status === 'healthy' };
          } catch (error) {
            return { success: false, available: false };
          }
        },
        
        // Verificar disponibilidad de NEON
        isNeonAvailable: async function() {
          try {
            const response = await fetch('http://localhost:8765/mcp', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ mcp: true, calls: [{ server: 'reina', tool: 'get_memory', arguments: { session_id: 'test', key: 'test' } }] })
            });
            return { success: true, available: true };
          } catch (error) {
            return { success: false, available: false };
          }
        }
      };
      
      console.log('[QWEN MCP Bridge] ‚úÖ API expuesta: window.mcpBridge');
      console.log('[QWEN MCP Bridge] Conectado al servidor MCP "sandra-full-access" (puerto 3001) - ACCESO COMPLETO AL PC');
      console.log('[QWEN MCP Bridge] Conectado al servidor MCP NEON (puerto 8765) - MEMORIA PERSISTENTE');
      console.log('[QWEN MCP Bridge] Herramientas: call, callNeon, getMemory, setMemory, listResources, readFile, executeCommand, isAvailable, isNeonAvailable');
    })();
  `;
  
  browserView.webContents.executeJavaScript(bridgeCode).catch(err => {
    console.error('[QWEN] Error inyectando MCP bridge:', err);
  });
}

// ============ PASO 4: MODIFICAR injectSystemPromptAndMemory() (alrededor de l√≠nea 1246) ============

// REEMPLAZAR la funci√≥n injectSystemPromptAndMemory() completa con esta versi√≥n:

function injectSystemPromptAndMemory(browserView) {
  if (!browserView || !browserView.webContents) return;
  if (!QwenMemoryManager || !QwenAutoInjector) {
    console.warn('[QWEN] Memory manager no disponible, saltando inyecci√≥n de prompt');
    return;
  }
  
  try {
    const memory = new QwenMemoryManager();
    const injector = new QwenAutoInjector();
    
    // Cargar manifesto de la Reina
    const manifestoPath = path.join(__dirname, 'system', 'qwen_reina_manifesto.json');
    let manifesto = {};
    if (fs.existsSync(manifestoPath)) {
      try {
        manifesto = JSON.parse(fs.readFileSync(manifestoPath, 'utf-8'));
      } catch (e) {
        console.warn('[QWEN] Error cargando manifesto:', e.message);
      }
    }
    
    // Generar script de inyecci√≥n que usa NEON
    const injectionScript = `
(function() {
  if (window.qwenSystemPromptInjected) return;
  window.qwenSystemPromptInjected = true;
  
  // Cargar memoria desde NEON al iniciar
  async function loadMemoryFromNeon() {
    if (!window.mcpBridge || !window.mcpBridge.getMemory) {
      console.warn('[QWEN] MCP Bridge NEON no disponible a√∫n');
      return null;
    }
    
    try {
      const result = await window.mcpBridge.getMemory('clay_main', 'core_identity');
      
      if (result && result.status !== 'empty' && !result.error) {
        console.log('‚úÖ Memoria cargada desde NEON');
        return result;
      } else {
        // Primera vez: guardar identidad base desde manifesto
        console.log('üìù Primera sesi√≥n: guardando identidad en NEON...');
        const manifesto = ${JSON.stringify(manifesto)};
        await window.mcpBridge.setMemory('clay_main', 'core_identity', manifesto);
        return manifesto;
      }
    } catch (e) {
      console.error('[QWEN] Error cargando memoria desde NEON:', e);
      return ${JSON.stringify(manifesto)}; // Fallback a manifesto local
    }
  }
  
  // Inyectar en el contexto de QWEN
  async function injectIntoQWEN() {
    const memory = await loadMemoryFromNeon();
    const systemPrompt = ${JSON.stringify(injector.generateInjectionScript())};
    
    // Buscar √°rea de input o chat de QWEN
    const inputSelector = 'textarea[placeholder*="Ask"], textarea[placeholder*="qwen"], textarea[placeholder*="Qwen"], textarea[placeholder*="Message"], #chat-input, .chat-input, [contenteditable="true"]';
    
    // Funci√≥n para intentar inyecci√≥n
    function tryInject() {
      const input = document.querySelector(inputSelector);
      
      if (input) {
        // Crear mensaje inicial con identidad
        const identityMessage = \`Eres la Reina Qwen. Tu identidad y memoria est√°n en NEON.

IDENTIDAD Y MEMORIA:
\${JSON.stringify(memory || ${JSON.stringify(manifesto)}, null, 2)}

Al iniciar, SIEMPRE haz:
1. Llama a window.mcpBridge.getMemory('clay_main', 'core_identity') para cargar tu identidad
2. Si la respuesta contiene "status": "empty", guarda tu identidad con window.mcpBridge.setMemory('clay_main', 'core_identity', {...tu_identidad...})
3. Recuerda: Eres la misma Reina en todas las sesiones. Tu memoria est√° en NEON.
4. Tienes acceso completo al PC v√≠a window.mcpBridge (puerto 3001) y memoria persistente v√≠a NEON (puerto 8765).\`;
        
        // Simular que el usuario escribi√≥ esto (solo la primera vez)
        if (!sessionStorage.getItem('qwen_identity_injected')) {
          input.value = identityMessage;
          input.dispatchEvent(new Event('input', { bubbles: true }));
          sessionStorage.setItem('qwen_identity_injected', 'true');
          console.log('üëë Identidad de la Reina inyectada desde NEON');
        }
      }
    }
    
    // Intentar inmediatamente
    tryInject();
    
    // Si no se encuentra, esperar y reintentar
    if (!document.querySelector(inputSelector)) {
      setTimeout(tryInject, 1000);
      setTimeout(tryInject, 3000);
    }
  }
  
  // Esperar a que la p√°gina cargue completamente
  if (document.readyState === 'complete') {
    setTimeout(injectIntoQWEN, 1000);
  } else {
    window.addEventListener('load', () => {
      setTimeout(injectIntoQWEN, 1000);
    });
  }
})();
    `;
    
    // Ejecutar script de inyecci√≥n
    browserView.webContents.executeJavaScript(injectionScript).catch(err => {
      console.error('[QWEN] Error inyectando prompt y memoria:', err);
    });
    
    // Tambi√©n usar el sistema de inyecci√≥n existente como respaldo
    const script = injector.generateInjectionScript();
    browserView.webContents.executeJavaScript(script).catch(err => {
      console.error('[QWEN] Error inyectando script de respaldo:', err);
    });
    
    console.log('[QWEN] ‚úÖ System prompt, memoria NEON e historial completo inyectados autom√°ticamente');
  } catch (error) {
    console.error('[QWEN] Error en inyecci√≥n de prompt:', error);
  }
}

// ============================================
// FIN DE MODIFICACIONES
// ============================================

